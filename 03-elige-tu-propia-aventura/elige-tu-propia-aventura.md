# Elige tu propia aventura

El objetivo del ejercicio es reproducir en formato web uno de los libros de "[Elige tu propia aventura](https://es.wikipedia.org/wiki/Elige_tu_propia_aventura)".

Las historias se proporcionan en formato JSON con la siguiente estructura:

```json
{
  // Each story arc will have a unique key that represents
  // the name of that particular arc.
  "story-arc": {
    "title": "A title for that story arc. Think of it like a chapter title.",
    "story": [
      "A series of paragraphs, each represented as a string in a slice.",
      "This is a new paragraph in this particular story arc."
    ],
    // Options will be empty if it is the end of that
    // particular story arc. Otherwise it will have one or
    // more JSON objects that represent an "option" that the
    // reader has at the end of a story arc.
    "options": [
      {
        "text": "the text to render for this option. eg 'venture down the dark passage'",
        "arc": "the name of the story arc to navigate to. This will match the story-arc key at the very root of the JSON document"
      }
    ]
  },
  ...
}
```

Vamos a importar la historia en una *struct* usando el servicio online [JSON to Go](https://mholt.github.io/json-to-go/), que permite convertir un fichero JSON en la definición de una *struct* en Go.

El resultado es:

```go
type AutoGenerated struct {
    Intro struct {
        Title   string   `json:"title"`
        Story   []string `json:"story"`
        Options []struct {
            Text string `json:"text"`
            Arc  string `json:"arc"`
        } `json:"options"`
    } `json:"intro"`
}
```

## Paquete `cyoa`(*Choose your own adventure*)

Creamos un *package*  `cyoa` y pegamos la definición de la *struct* creada a partir del fichero JSON.

Sin embargo, en vez de tener un *struct* con varios *niveles*, disponer de *structs* separadas proporciona más flexibilidad, por lo que separamos la definición de la *struct* original en dos (también cambiamos algunos nombres):

```go
type Chapter struct {
  Title      string   `json:"title"`
  Paragraphs []string `json:"paragraphs"`
  Options    []Option `json:"options"`
}

type Option struct {
  Text    string `json:"text"`
  Chapter string `json:"chapter"`
}
```

La historia completa será un *map* en el que cada entrada contiene el nombre de un capítulo; algo del estilo `map[string]Chapter`.

Sin embargo, podemos *ocultar* los detalles de implementación definiendo un nuevo tipo de variable `Story`:

```go
type Story map[string]Chapter
```

De esta forma, a nivel conceptual, el desarrollador sólo se ocupa de manipular "historias", independientemente de cómo están implementadas, lo que puede facilitar el desarrollo.

## Servidor web

En general, una buena práctica es crear una carpeta `cmd` para cada uno de los comandos de la aplicación y después construir un binario que ejecutar... En nuestro caso, sólo va a tener uno, el componente encargado de publicar la historia en el navegador.

Creamos la carpeta:

```bash
mkdir -p cmd/cyoaweb
```

Dentro de esta carpeta construimos la aplicación.

Empezamos con la importación del fichero JSON que contiene la historia. El nombre del fichero lo pasamos como parámetro desde la CLI al programa.

Usamos el paquete `flag` y especificamos el fichero `gopher.json` como valor por defecto.

Mostramos el nombre del fichero desde el que cargamos la historia y a continuación abrimos el fichero.

Como el fichero está en formato JSON, usamos `json.NewDecoder()`. `json.NewDecoder` toma como parámetro un *Reader* (en este aso, el puntero al fichero); lo *descodificamos* y si no tenemos un error, lo mostramos por pantalla (para ver que todo funciona).

> Jon usa la forma *compacta*:
>
> ```go
> if 	err := d.Decode(&story); err != nil {
>      panic(err)
> }
> ```
> en la que asigna el resultado de *decodificar* el fichero y comprobar si hay un error en la misma  línea.
>
> Esto es equivalente a:
>
> ```go
> err = d.Decode(&story);
> if err != nil {
>    panic(err)
> }
> ```

Usamos `%+v` en `fmt.Printf()` para mostrar la *struct* con los valores obtenidos desde el fichero JSON (con `+`, también se muestran los nombres de los campos de la *struct*):

```bash
$ go run cmd/cyoaweb/main.go 
Using the story from file gopher.json.
map[debate:{Title:The Great Debate Paragraphs:[] Options:[{Text:Clearly that man in the fox outfit was the winner. Chapter:} {Text:I don't think
...
```

En este punto ya hemos comprobado que somos capaces de cargar el fichero con la historia y *parsearlo* en una *Struct*.

## *Refactor*

Una vez esta parte de la aplicación funcionando, *refactorizamos* para mejorar la calidad del código, de manera que sea más sencillo de mantener.

En general, la parte que vamos a tener que modificar más frecuentemente es la parte de *descodificación* y *parseo* del fichero JSON, por lo que quizás tiene más sentido que forme parte del *type* `Story`.

Movemos el código:

```go
  d := json.NewDecoder(f)
  var story cyoa.Story
  err = d.Decode(&story)
  if err != nil {
    panic(err)
  }
```

al fichero `story.go` y lo convertimos en una función `JsonStory`.

Esta función toma como argumento un `io.Reader` y devolverá una `Story` (y un `error`):

```go
// Punto de partida!!
func JsonStory(r io.Reader) Story, error {
  d := json.NewDecoder(r)
  var story cyoa.Story
  err = d.Decode(&story)
  if err != nil {
    panic(err)
  }
}
```

Cambiamos `f` por `r` como parámetro para `json.NewDecoder` y hacemos que en caso de error, en vez de lanzar un *panic*, devolvemos `nil` (no hay `Story`) y el error que se haya producido.

Si no se ha producido un error, devolvemos la `Story` (y `nil`).

Volviendo a `cmd/cyoaweb/main.go`, el bloque que hemos convertido en la función `JsonStory` se convierte en:

```go
	story, err := cyoa.JsonStory(f)
	if err != nil {
		panic(err)
	}
```

En realidad no hemos *reducido* el número de líneas de código, pero quizás tiene más sentido esta nueva organización, lo que puede simplificar el mantenimiento del código.

